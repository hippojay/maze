<!DOCTYPE html>
<html>
<head>
    <title>Reversed Maze Challenge</title>
    <style>
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        .maze {
            border: 2px solid #333;
            margin: 20px;
            background: #f0f0f0;
        }
        .controls {
            margin: 20px;
            padding: 15px;
            background: #eee;
            border-radius: 5px;
            text-align: center;
            min-width: 300px;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
            font-size: 1.1em;
            color: #444;
        }
        .stat-item {
            background: white;
            padding: 8px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .stat-label {
            font-weight: bold;
            color: #666;
        }
        .cell {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            box-sizing: border-box;
        }
        .wall {
            background-color: #333;
        }
        .player {
            background-color: #ff4444;
            border-radius: 50%;
        }
        .goal {
            background-color: #44ff44;
        }
        .victory-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            text-align: center;
            display: none;
        }
        .mode-indicator {
            background: #ff6b6b;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .normal-mode {
            background: #4CAF50;
        }
        .control-info {
            margin: 10px 0;
            padding: 10px;
            background: #fff;
            border-radius: 4px;
            border-left: 4px solid #ff6b6b;
        }
        .reset-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 15px;
        }
        .reset-button:hover {
            background: #45a049;
        }
        .accuracy {
            color: #666;
            margin: 10px 0;
            font-style: italic;
        } 
        .control-mapping {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
            background: #fff;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #ff6b6b;
        }
        .control-item {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .arrow-key {
            display: inline-block;
            padding: 2px 8px;
            background: #eee;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-weight: bold;
        }
    </style>
</head>
    </style>
</head>
<body>
    <div class="game-container">
        <h2>Maze Challenge</h2>
        <div class="controls">
            <div id="modeIndicator"></div>
            <div id="controlToggle" style="display: none;">
                <label>
                    <input type="checkbox" id="reverseControls"> Reverse Controls
                </label>
            </div>
            <div id="controlInfo" class="control-info"></div>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">Valid Moves</div>
                    <div id="moveCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Invalid Moves</div>
                    <div id="invalidCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Time</div>
                    <div id="timer">0:00</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Accuracy</div>
                    <div id="accuracy">100%</div>
                </div>
            </div>
        </div>
        <div id="maze" class="maze"></div>
    </div>

    <div id="victoryModal" class="victory-modal">
        <h2>Congratulations!</h2>
        <p>You solved the maze!</p>
        <div class="stats">
            <div class="stat-item">
                <div class="stat-label">Valid Moves</div>
                <div id="finalMoves">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Invalid Moves</div>
                <div id="finalInvalid">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Time</div>
                <div id="finalTime">0:00</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Accuracy</div>
                <div id="finalAccuracy">100%</div>
            </div>
        </div>
        <div class="accuracy" id="accuracyMessage"></div>
        <button class="reset-button" onclick="resetGame()">Play Again</button>
    </div>

    <script>
        // Initialize game state and constants
        const MAZE_WIDTH = 15;
        const MAZE_HEIGHT = 15;
        const EMPTY = 0;
        const WALL = 1;
        const PLAYER = 2;
        const GOAL = 3;

    // Define possible directions
    const DIRECTIONS = {
        UP: { dx: 0, dy: -1 },
        DOWN: { dx: 0, dy: 1 },
        LEFT: { dx: -1, dy: 0 },
        RIGHT: { dx: 1, dy: 0 }
    };

    // Function to shuffle an array randomly
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    // Function to generate random control mappings
    function generateRandomControls() {
        // Create arrays of keys and directions
        const keys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
        const directions = Object.entries(DIRECTIONS);
        
        let validMapping = false;
        let controlMapping = {};

        // Keep generating mappings until we get one where no control is in its normal position
        while (!validMapping) {
            // Shuffle the directions
            const shuffledDirections = shuffleArray([...directions]);
            
            // Create the mapping
            controlMapping = {};
            let hasNormalMapping = false;

            keys.forEach((key, index) => {
                controlMapping[key] = shuffledDirections[index][1];
                
                // Check if this is a normal mapping
                if ((key === 'ArrowUp' && shuffledDirections[index][0] === 'UP') ||
                    (key === 'ArrowDown' && shuffledDirections[index][0] === 'DOWN') ||
                    (key === 'ArrowLeft' && shuffledDirections[index][0] === 'LEFT') ||
                    (key === 'ArrowRight' && shuffledDirections[index][0] === 'RIGHT')) {
                    hasNormalMapping = true;
                }
            });

            // If no control is in its normal position, we have a valid mapping
            validMapping = !hasNormalMapping;
        }

        return controlMapping;
    }
        
        // Check URL parameter for control mode
        const urlParams = new URLSearchParams(window.location.search);
        const normalControls = urlParams.has('normal');
        
        // Game state
        let playerPos = { x: 1, y: 1 };
        let moveCount = 0;
        let invalidMoveCount = 0;
        let timeElapsed = 0;
        let timerInterval = null;
        let gameStarted = false;
        let controlMapping = generateRandomControls();

// Function to create a readable description of controls
    function getControlDescription() {
        const keyToSymbol = {
            'ArrowUp': '↑',
            'ArrowDown': '↓',
            'ArrowLeft': '←',
            'ArrowRight': '→'
        };

        const directionToWord = {
            '0,-1': 'UP',
            '0,1': 'DOWN',
            '-1,0': 'LEFT',
            '1,0': 'RIGHT'
        };

        let description = '<div class="control-mapping">';
        Object.entries(controlMapping).forEach(([key, direction]) => {
            const dirString = directionToWord[`${direction.dx},${direction.dy}`];
            description += `
                <div class="control-item">
                    <span class="arrow-key">${keyToSymbol[key]}</span>
                    <span>moves ${dirString}</span>
                </div>`;
        });
        description += '</div>';
        return description;
    }
        
        // Create the maze layout
        const maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,0,1,0,0,0,0,0,0,0,1,0,0,1],
            [1,0,1,1,0,1,1,1,1,1,0,1,0,1,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,1,1,1,1,1,0,1,0,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,1,0,0,0,0,1,0,1],
            [1,0,1,1,1,1,1,1,1,1,1,0,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,1,0,0,0,1],
            [1,0,1,0,1,1,1,1,1,0,1,1,1,1,1],
            [1,0,1,0,1,0,0,0,1,0,0,0,0,0,1],
            [1,0,1,0,1,0,1,0,1,1,1,1,1,0,1],
            [1,0,0,0,1,0,1,0,0,0,0,0,1,0,1],
            [1,1,1,1,1,0,1,1,1,1,1,0,1,0,1],
            [1,0,0,0,0,0,1,0,0,0,0,0,0,3,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        // Update UI based on control mode
  function updateControlsUI() {
        const controlInfo = document.getElementById('controlInfo');
        controlInfo.innerHTML = getControlDescription();
    }

        // Calculate and update accuracy
        function updateAccuracy() {
            const totalMoves = moveCount + invalidMoveCount;
            const accuracy = totalMoves === 0 ? 100 : Math.round((moveCount / totalMoves) * 100);
            document.getElementById('accuracy').textContent = `${accuracy}%`;
            return accuracy;
        }

        function getAccuracyMessage(accuracy) {
            if (accuracy >= 90) return "Excellent navigation! You rarely made wrong moves!";
            if (accuracy >= 75) return "Good job! Try to watch for walls to improve accuracy.";
            if (accuracy >= 60) return "Not bad! Practice planning your route to avoid walls.";
            return "Keep practicing! Try to plan your moves carefully.";
        }

        // Timer functions
        function startTimer() {
            if (!gameStarted) {
                gameStarted = true;
                timerInterval = setInterval(() => {
                    timeElapsed++;
                    updateTimer();
                }, 1000);
            }
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function updateTimer() {
            document.getElementById('timer').textContent = formatTime(timeElapsed);
        }

        // Function to show victory modal
        function showVictoryModal() {
            const modal = document.getElementById('victoryModal');
            const accuracy = updateAccuracy();
            
            document.getElementById('finalMoves').textContent = moveCount;
            document.getElementById('finalInvalid').textContent = invalidMoveCount;
            document.getElementById('finalTime').textContent = formatTime(timeElapsed);
            document.getElementById('finalAccuracy').textContent = `${accuracy}%`;
            document.getElementById('accuracyMessage').textContent = getAccuracyMessage(accuracy);
            
            modal.style.display = 'block';
        }

        // Update move counters
        function updateMoveCounters() {
            document.getElementById('moveCount').textContent = moveCount;
            document.getElementById('invalidCount').textContent = invalidMoveCount;
            updateAccuracy();
        }

        // Render the maze
        function renderMaze() {
            const mazeElement = document.getElementById('maze');
            mazeElement.innerHTML = '';
            mazeElement.style.display = 'grid';
            mazeElement.style.gridTemplate = `repeat(${MAZE_HEIGHT}, 30px) / repeat(${MAZE_WIDTH}, 30px)`;

            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    if (maze[y][x] === WALL) {
                        cell.classList.add('wall');
                    } else if (x === playerPos.x && y === playerPos.y) {
                        cell.classList.add('player');
                    } else if (maze[y][x] === GOAL) {
                        cell.classList.add('goal');
                    }
                    
                    mazeElement.appendChild(cell);
                }
            }
        }

        // Handle player movement
        function movePlayer(key) {
        startTimer();

        if (controlMapping[key]) {
            const { dx, dy } = controlMapping[key];
            const newX = playerPos.x + dx;
            const newY = playerPos.y + dy;

            if (newX >= 0 && newX < MAZE_WIDTH && 
                newY >= 0 && newY < MAZE_HEIGHT && 
                maze[newY][newX] !== WALL) {
                
                moveCount++;
                playerPos.x = newX;
                playerPos.y = newY;
                renderMaze();

                if (maze[newY][newX] === GOAL) {
                    stopTimer();
                    showVictoryModal();
                }
            } else {
                invalidMoveCount++;
            }
            
            updateMoveCounters();
        }
    }

        // Reset game to initial state
  function resetGame() {
        playerPos = { x: 1, y: 1 };
        moveCount = 0;
        invalidMoveCount = 0;
        timeElapsed = 0;
        gameStarted = false;
        controlMapping = generateRandomControls();
        document.getElementById('victoryModal').style.display = 'none';
        updateMoveCounters();
        updateTimer();
        updateControlsUI();
        renderMaze();
    }

            // Modified event listener for keyboard input
    document.addEventListener('keydown', (e) => {
        if (!gameStarted || document.getElementById('victoryModal').style.display === 'block') {
            if (e.key.startsWith('Arrow')) {
                startTimer();
            }
        }
        
        if (e.key.startsWith('Arrow')) {
            movePlayer(e.key);
        }
    });

        if (normalControls) {
            document.getElementById('reverseControls').addEventListener('change', (e) => {
                isReversed = e.target.checked;
                updateControlsUI();
            });
        }

        // Initialize the game
    // Initialize the game
    function initGame() {
        renderMaze();
        updateMoveCounters();
        updateTimer();
        updateControlsUI();
    }

        // Start the game
        initGame();
    </script>
</body>
</html>
